# Course: Financial Econometrics
# Reviewed and modified by Huei-Wen Teng 
# Last update 20240227

library(PoEdata)

data(food)

?food

plot(food$income, food$food_exp)
 
head(food);		# print the first five rows
tail(food);       # print the last five rows

food

##
plot(food$income, food$food_exp, 
     ylim=c(0, max(food$food_exp)),
     xlim=c(0, max(food$income)),
     xlab="weekly income in $100", 
     ylab="weekly food expenditure in $", 
     type = "p")

# you can not just call food_exp, or income. 
food_exp
income 

# Instead, you have to do this: 
food$food_exp
food$income

# Define two new variables 
#food_exp = food$food_exp
#income = food$income 


# fit the model to the data
# lm= linear model 
mod1 <- lm(food_exp ~ income, data = food)

coef(mod1)
b1 <- coef(mod1)[[1]]
b2 <- coef(mod1)[[2]]
b1
b2

mod1
smod1 <- summary(mod1)
smod1

## Do a scatter plot of the data and add the fitted regression line 
plot(food$income, food$food_exp, 
     ylim=c(0, max(food$food_exp)),
     xlim=c(0, max(food$income)),
     xlab="weekly income in $100", 
     ylab="weekly food expenditure in $", 
     type = "p")
abline(b1,b2)		# add the estimated (fitted) regression line

names(mod1)			# to see what's inside the object
names(smod1)

mod1$coefficients
smod1$coefficients
coef(mod1)

# retrive the residuals and do a simple diagnostic test
r = resid(mod1)
r 

mod1$residuals 	# This is another to retrieve residuals 

# We would like to check if residuals are iid normal 
plot(r)		         # scattor plot 
					# 1. zero moving average 
					# 2. varinace spread out
plot(food$income, r)
hist(r)            # histogram (it looks symmetric) 
plot(density(r))   # denisty plot
qqnorm(r)          # qqplot: A good tool for you to say whether it is normally distributed  

# Show you how a normally distributed data looks like
n = 10; 
data = rnorm(n, mean = 0, sd = 1)
data
hist(data)
plot(density(data))
qqnorm(data)


# prediction
newx <- data.frame(income = c(20, 25, 27))
newx
yhat <- predict(mod1, newx)
yhat
names(yhat) <- c("income=$2000", "$2500", "$2700") 
yhat  # prints the result

# Do a Simulation study to understand the 
# sampling properties of the estimators
# (1) draw the pdf of the independent variable 
# in the food expenditure model: 
# y = b1 + b2*x + e (Here, only x is used from the food data 
# and assumed to be known  
# y is generated by the model)
N <- 40
x1 <- 10
x2 <- 20
b1 <- 100
b2 <- 10
mu <- 0
sig2e <- 2500
sde <- sqrt(sig2e)
yhat1 <- b1+b2*x1
yhat2 <- b1+b2*x2
curve(dnorm(x, mean=yhat1, sd=sde), 0, 500, col="blue")
curve(dnorm(x, yhat2, sde), 0,500, add=TRUE, col="red")
abline(v=yhat1, col="blue", lty=2)
abline(v=yhat2, col="red", lty=2)
legend("topright", legend=c("f(y|x=10)", "f(y|x=20)"), lty=1,col=c("blue", "red"))

# (2) Calculate the theoretical distribution of b_2
x <- food$income
x
xbar <- mean(x)
sumx2 <- sum((x-xbar)^2)
varb2 <- sig2e/sumx2
sdb2 <- sqrt(varb2)
leftlim <- b2-3*sdb2
rightlim <- b2+3*sdb2
curve(dnorm(x, mean=b2, sd=sdb2), leftlim, rightlim)
abline(v=b2, lty=2)


# (3) Use x in the food dataset to generate price y. 
# Check b1hat, b2hat, and seb2hat
set.seed(12345)
# imagine we are the creator will produce data (x,y) using the model
# model: y = b1 + b2 *x + error
# Assume: b1, b2, x are known 

#x <- food$income
y <- b1+b2*x+rnorm(N, mean=0, sd=sde)
plot(x, y) # simulated data
mod6 <- lm(y~x)
b1hat <- coef(mod6)[[1]]
b2hat <- coef(mod6)[[2]]
mod6summary <- summary(mod6) #the summary contains the standard errors
seb2hat <- coef(mod6summary)[2,2]
b1hat
b2hat
seb2hat


# (4) Use x in the food dataset and implement a simluation study 
# to understand the sampling properties of b1, b2, and the erros. 
N <- 40
x <- food$income
nrsim <- 1000
sde <- 50
vb2 <- numeric(nrsim) #stores the estimates of b2
for (i in 1:nrsim){
  set.seed(12345+10*i)
  y <- b1+b2*x+rnorm(N, mean=0, sd=sde)
  mod7 <- lm(y~x)
  vb2[i] <- coef(mod7)[[2]]
}
mb2 <- mean(vb2)
seb2 <- sd(vb2)

# (5) Summarize the results
plot(density(vb2))
curve(dnorm(x, b2, sdb2), col="red", add=TRUE)
abline(v = b2, col="red");

legend("topright", legend=c("true", "simulated"), 
       lty=1, col=c("black", "red")) # modified by Teng on 2021/3/9
 
hist(vb2, prob=TRUE, ylim=c(0,.4))
curve(dnorm(x, mean=b2, sd=sdb2), col="red", add=TRUE) # 

vcov(mod1) # show you the data


### Many applications require estimates of the variances and covariances of the regression coefficients. R stores them in the a matrix vcov():
varb1 <- vcov(mod1)[1, 1]
varb1
varb2 <- vcov(mod1)[2, 2]
varb2
covb1b2 <- vcov(mod1)[1,2]
covb1b2
vcov(mod1)


### 2.8 Estimating nonlinear relationship 

### PRICE = beta1+ beta2*SQFT^2 + e
data(br) 
?br # show information of the dataset br  
head(br)
tail(br)
# visualizing your data
# Data visualization
# EDA (exploratory data analysis)
plot(br$sqft, br$price)

# try-and-error
# try to fit a linear model 
mod0 <- lm(price~sqft, data=br)
mod0
mod0b1 = coef(mod0)[[1]]
mod0b1
mod0b2 = coef(mod0)[[2]]
mod0b2

plot(br$sqft, br$price, xlab="Total square feet", 
     ylab="Sale price, $", col="grey") # scattor plot
abline(mod0b1, mod0b2, col="red")

# check residuals for model diagnostics
res0 = resid(mod0) # curvture and non-constant patterns, outliers
plot(res0) # 1-st residuals plot against observation order

plot(br$sqft, res0) # 2-nd residuals plot: residuals against x=> 
hist(res0) # skewed to the right
qqnorm(res0)

# Rediuals checks suggest a modification of the model
# PRICE = beta1+ beta2*SQFT^2 + e

mod3 <- lm(price~I(sqft^2), data=br)
mod3

smod3 = summary(mod3)

b1 <- coef(mod3)[[1]]
b1
b2 <- coef(mod3)[[2]]
b2

sqftx=c(2000, 4000, 6000) #given values for sqft
pricex=b1+b2*sqftx^2 #prices corresponding to given sqft 
DpriceDsqft <- 2*b2*sqftx # marginal effect (slope) of sqft on price
DpriceDsqft
# elasticity1 equals elasticity2  
elasticity1 = DpriceDsqft*sqftx/pricex 
elasticity2 = 2*b2*sqftx^2/(b1+b2*sqftx^2)

# Fit a quadratic model 
plot(br$sqft, br$price, xlab="Total square feet", 
     ylab="Sale price, $", col="grey") # scattor plot
curve(b1+b2*x^2, col="red", add=TRUE)   # add the quadratic curve to the scatter plot:


# Check residuals for model diagnostics
res3 = resid(mod3)
plot(res3) # 1st residuals plot 
plot(br$sqft, res3) # 2st residuals plot 

hist(res3) # residuals appear to symmetrically distributed
qqnorm(res3) # symmetric but heavy tails


### The log-linear model
# log(SQFT) = beta1 + beta2 SQFT + e_i
data(br)
hist(br$price, col='grey') # price skewwed to the right
hist(log(br$price), col='grey') # log(price) is more symmetrically distributed
mod4 <- lm(log(price)~sqft, data=br)
mod4
ordat <- br[order(br$sqft), ] #order the dataset
mod4 <- lm(log(price)~sqft, data=ordat)
mod4
plot(br$sqft, br$price, col="grey")
lines(exp(fitted(mod4))~ordat$sqft, 
      col="blue", main="Log-linear Model")


### Using indicator variables in regression
data(utown)
?utown
price0bar <- mean(utown$price[which(utown$utown==0)])
price1bar <- mean(utown$price[which(utown$utown==1)])
price0bar		
price1bar
price1bar - price0bar # the average difference in house price if it is a university town house

mod5 <- lm(price~utown, data=utown)
mod5

b1 <- coef(mod5)[[1]] 
b2 <- coef(mod5)[[2]]
b1;b2;
